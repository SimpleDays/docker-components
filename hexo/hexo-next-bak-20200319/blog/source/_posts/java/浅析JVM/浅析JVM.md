---
title: 浅析JVM
permalink: {{ title }}
date: 2020-03-11
tags:
categories: JAVA
---

### JAVA体系组成部分
#### JAVA程序设计语言
    Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。
    Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。
<!--more-->
#### JAVA Class文件格式
    Java字节码可以跨不同的虚拟机在不同的平台上执行，这些字节码按照class文件格式的规范组成了class文件，从而为Java语言跨平台执行奠定了基石。
    不同的语言都可以根据class文件格式生成可以在JVM上执行的字节码，这又给Java平台带来了新的血液。
    Class文件结构采用类似C语言的结构体来存储数据的，主要有两类数据项，无符号数和表，无符号数用来表述数字，索引引用以及字符串等，比如 u1，u2，u4，u8分别代表1个字节，2个字节，4个字节，8个字节的无符号数，而表是有多个无符号数以及其它的表组成的复合结构，习惯地以_info结尾。
    表用于描述有层次关系的符合结构的数据，整个Class文件本质上就是一张表。
```
ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```
    magic[4字节] 魔数，用来判断是否可以被虚拟机使用。固定值为0xCAFEBABE（咖啡宝贝）
    minor_version[2字节] 次版本号
    major_version[2字节] 主版本号，低版本的jdk无法执行高版本的class文件。
    constant_pool_count[2字节] 常量池里的项目个数
    constant_pool 常量池里每一个项目类型都用一个tag标示。从1开始取值，比如取值为1时，表示info里存放的是utf8的字符串
    　　tag[1字节] 不同的取值，决定了其下info的结构不同
    　　info
    access_flags[2字节] 类的访问标识位，用来标识类是否具有pulbic/abstract/interface/final等修饰符。用其中的bit位标识是否存在。例如，如果是public的class，其值为0x0001
    this_class[2字节] 两个字节的数值，指向常量池里的某一个项目。这里指向的是当前类的全名称
    super_class[2字节] 指向常量池里的当前类的父类全名称
    interfaces_count[2字节] 当前类实现的接口个数
    interfaces 每一个指向常量池里的接口的全名称
    
    fields_count[2字节] 当前类的成员变量个数
    fields 成员变量信息
    　　access_flags[2字节] 成员变量的访问标识，与上边access_flags相似
    　　name_index[2字节] 指向常量池里当前字段的名字
    　　desc_index[2字节] 指向常量池里当前字段的描述。例如字符串类型对应的描述是'Ljava.lang.String;'
    　　attribute_count[4字节] 字段的属性表个数，跟类的属性表类似。在下面介绍
    　　attributes 存放字段的属性信息
    
    methods_count[2字节] 当前类的成员方法个数
    mehtods 成员方法信息
    　　access_flags[2字节] 成员方法的访问标识，与上边access_flags相似
    　　name_index[2字节] 指向常量池里当前方法的名字
    　　desc_index[2字节] 指向常量池里当前方法的签名。比如 public String test(Object o) 方法对应描述是(Ljava.lang.Object;)Ljava.lang.String;
    　　attributes_count[4字节] 方法的属性表个数，跟类的属性表类似。在下面介绍
    　　attributes 存放方法的属性信息，最重要的属性就是Code,存放了方法的字节码指令
    
    attributes_count[2字节] 类的属性表个数
    attributes 类的属性信息
    　　attribute_name_index[2字节] 指向常量池里属性的名称
    　　attribute_length[4字节] 下边info内容的长度
    　　info 属性的内容。不同的属性，内容结构不同

    以Code属性表为例，其结构如下
    attribute_name_index[2字节] 指向常量池里的Code字符串
    attribute_length[4字节] 该属性的长度
    max_stack[2字节] 当前方法操作数栈的最大深度
    max_locals[2字节] 存放局部变量所需要的空间个数
    code_length[4字节] 源码编译后字节码指令的长度
    code 字节码指令
    exception_table_length 异常表个数
    exception_table 异常表
    attributes_count 当前属性下的属性个数
    attributes
    
    符号引用与直接引用
    符号引用：对于目标类的，比如对于一个类的全局类名的描述，存放在常量池中的。
    直接引用：是符合引用的内存地址，有时候在加载（或者第一次使用）的时候符号引用转换过来，有时候在【每次】在运行期间进行转换。分别称为静态解析（绑定）及动态连接。这种动态体现为Java的多态性。
    
#### JAVA虚拟机
    虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。
    Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。
    JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。
#### JAVA API类库
    Java 语言的强大之处在于它预先定义好了多种多样的类库，程序设计师可以直接使用这些已经被打包好的接口和类来实现具体的功能。在编写程序时直接导入就行了，不需要自己重新写，大大提高了编程的效率和质量。
    比如Object类、String类等。
#### 来自商业机构和开源社区的第三方JAVA类库
    ...

### JDK和JRE有什么区别
    JDK 
        Java程序设计语言、Java虚拟机和Java API类库这三部分统称为JDK（Java Development Kit)。JDK是用于支持Java程序开发的最小环境，即如果你要进行Java开发，你至少要在你的开发机器上安装JDK。
        1.Java程序设计语言
        2.Java虚拟机
        3.Java API类库
    JRE 
        Java SE API子集和Java虚拟机这两部分统称为JRE，JRE是支持Java程序运行的标准环境，如果你不需要进行Java程序开发，只是要运行Java程序，例如运行Jar文件，那么你可以在你的运行机器上只安装JRE。
        1.Java虚拟机
        2.Java API类库中的Java SE API子集
![](/images/java/浅析JVM/jdk_vs_jre.png)

### Java内存区域（运行时数据区域）
#### 程序计数器（线程私有）​
    1. 程序计数器可以看作当前线程执行的字节码的行号指示器，在虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个程序计数器来完成。
    2. Java虚拟机为了多线程情况下，线程切换后能恢复到正确的执行位置，所以每个线程都有一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，所以我们也称程序计数器这类的内存区域为“线程私有”的内存，它们的生命周期与线程相同。
    3. 如果线程正在执行的是一个Java方法，这个程序计数器记录的是正在执行的虚拟机字节码指令地址；如果正执行的是Native方法，这个计数器的值则为空（undefine）。
    4. 程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变。所以此内存区域不会出现OutOfMemoryError的情况。
#### Java虚拟机栈（线程私有）
    1. Java虚拟机栈与程序计数器一样，为当前线程私有，它的生命周期与线程相同；
    2. Java虚拟机栈描述的是Java方法执行的内存模型。每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程；
    3. 局部变量存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float等）、对象引用（reference类型，它不等同于对象本身，它可能只是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其它与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。
    4. 局部变量所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小；
    5. 该区域规定了两种异常情况：
        ① 如果线程请求的栈深度大于虚拟机所允许的深度，也就是需要被栈存储的数据大于当前虚拟机栈的最大容量，出现栈溢出情况(栈溢出情况分为上溢出和下溢出，下溢出就是当前栈已为空而仍在执行出栈操作所导致的)。将抛出StackOverFlowError异常；
        ② 如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，这种情况一般只会出现在多线程情况下，因为虚拟机数据单个线程私有，在多线程情况下，虚拟机栈随着线程的建立不断被建立，直到有一个虚拟机栈在创建时出现内存溢出情况，就会抛出OutOfMemoryError异常。
#### 本地方法栈（线程私有）
    1. 本地方法栈与虚拟机栈比较类似，虚拟机栈服务于虚拟机执行的Java方法，本地方法栈服务于虚拟机使用到的Native方法；
    2. 线程私有，生命周期与线程相同；
    3. 虚拟机规范中对本地方法栈中的方法使用的语言、使用的方式与数据结构被没有强制的规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（如Sun HotSpot虚拟机）直接就把本地方法和虚拟机栈合二为一；
    4. 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
#### Java堆（所有线程共享）
    1. Java堆是被所有线程共享的一块内存区域。
    2. 在虚拟机启动时创建，用来存放对象实例，几乎所有对象实例都在这里分配内存；
    3. Java堆是垃圾收集器管理的主要区域，因此有很多时候也被称为“GC堆”。从内存回收的角度看，由于现在的收集器基本上都是采用的分代收集算法，所以Java堆中还可以细分为新生代和老年代；再细致一点又有Eden空间、From Survivor空间和To Survivor空间三个部分；
    4. 从内存分配的角度来讲，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例。进一步划分的目的是为了更好的回收内存，或者更快的分配内存;例如在对象创建过程中的内存分配，就需要考虑多线程情况下的线程安全问题，除了对分配动作进行同步处理以外，还提出了一种以单个线程单独在Java堆上分配一块内存作为缓冲区，使每个对象的分配操作互不影响，从而解决并发线程安全问题。除此之外，还有G1垃圾收集器将Java堆内存划分为很多个独立的Region，虚拟机将维护一个优先列表，将每个Region区域回收的价值对比，优先回收在当前所限制的回收停顿时间价值最大的一个Region区域。
    5. Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像磁盘空间一样。在实现时，既可以是现成固定的大小，也可以是可扩展的。简单而言也就是不需要连续内存，并且可以通过动态增加其内存。
    6. 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
    堆区是对GC效率影响最大的一块区域。它被分为三个区域，第一个是Young区，也就是堆区的新生代，用于保存刚实例化的对象，一般皆为“朝生夕死”的对象。第二个是Old区，也就是老年代，当新生区被填满时，GC会将对象转移到Old区。第三个是Permanent区，也就是永久代，用于保存反射对象。JVM一般有两个GC线程，第一个线程负责回收Heap的Young区。第二个线程在Heap不足时，遍历Heap，将Young区升级为Old区，此线程被迫运行时会降低JVM的性能。堆区示意图如下：
![](/images/java/浅析JVM/JVM堆参数.png)
#### 方法区（线程共享）
    1. 方法区与Java堆一样，是各个线程共享的内存区域；
    2. 方法区用于存储已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；
    3. 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现，HotSpot虚拟机把它当成永久代来进行垃圾回收；
    4. 和Java堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常；
    运行常量池：
        ① 运行时常量池在jdk1.7之前是方法区的一部分，但在jdk1.7时就存在消除“永久代”这一说，将运行时常量池放入堆区，在jdk1.8时可以说完全消除了这个“永久代”，将运行时常量池与方法区和堆区都相对独立，放入了元空间之中。与此类似的还有Class文件中的常量池。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放；
        ② Class文件的每一部分包括常量池的格式都有严格的规范，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。而运行时常量池Java虚拟机没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需求来实现这个内存区域；
        ③ 运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java并不要求常量一定只有在编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性表现较为突出的就是String类的intern（）方法；
        ④ 运行时常量池会受到方法区内存的限制，当常量池无法在申请到内存时，会抛出OutOfMemoryError异常。
    直接内存： 
        直接内存并不是虚拟机运行时数据区域的一部分，也不是Java虚拟机中定义的内存区域，但被频繁使用且可导致OutOfMemoryError异常出现。在JDK1.4中新加入NIO类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。本机直接内存的分配不会受到Java堆大小的限制，但会受到本机总内存大小及其处理器寻址空间的限制。如果服务管理员在配置虚拟机时忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。

![](/images/java/浅析JVM/JVM运行时数据区域.png)
![](/images/java/浅析JVM/JVM运行时数据区域2.png)

### 基于栈的指令集与基于寄存器的指令集
	//基于栈的指令
	iconst_1
	iconst_1
	iadd
	istore_0

	//基于寄存器指令
	mov eax, 1
	add eax, 1
| 栈式 VS 寄存器式 | 对比  | 
| -------- | -------- | 
| 指令条数     | 栈式 > 寄存器式     | 
| 代码尺寸     | 栈式 < 寄存器式     | 
| 移植性     | 栈式优于寄存器式     | 
| 指令优化     | 栈式更不易优化     | 
| 解释器执行速度     | 栈式解释器速度稍慢     | 
| 代码生成难度     | 栈式简单     | 
| 简易实现中的数据移动次数     | 栈式移动次数多     | 

### 什么叫字节码
    Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（操作数，Operands）构成。即：Java指令 = 操作码 + 操作数。
    由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。
    由于字节码指令集限制了其操作码长度为1个字节(0~255)，即意味着整个指令集中包含的指令总数不超过256条。
    Java虚拟机解释器的执行模型如下：
```
do {
    自动计算PC寄存器的值加1；
    根据PC寄存器的指示位置，从字节码中取出操作码；
    if (字节码存在操作数)  从字节码流中取出操作数；
    执行操作码所定义的操作；
} while (字节码流长度 > 0)
```
    加载和存储指令、
    运算指令、
    类型转换指令、
    对象创建与访问指令、
    操作数栈管理指令
    控制转移指令、
    方法调用和返回指令、
    异常处理指令和同步指令。

[字节码指令表](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html)
[字节码指令表](https://www.cnblogs.com/longjee/p/8675771.html)

### 类加载大概过程
    加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序进行，而解析阶段则不一定，它在某些情况下可能在初始化阶段后在开始，因为java支持运行时绑定。
![](/images/java/浅析JVM/JVM类加载过程.jpg)
#### 加载 
    在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情： 
    1. 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）； 
    2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 
    3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 
#### 验证 
    验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
    验证阶段大致会完成4个阶段的检验动作： 
    1. 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 
    2. 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 
    3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 
    4. 符号引用验证：确保解析动作能正确执行。

#### 准备 
    准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
    这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。

####解析 
    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 

#### 初始化 
    类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备极端，变量已经付过一次系统要求的初始值，
    而在初始化阶段，则根据程序猿通过程序制定的主管计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<clinit>()方法的过程.

### 类加载器
    JVM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器：
        1)根类加载器（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。
        由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。
        2)扩展类加载器（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。
        3)系统类加载器（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。
        程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。

    双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。
    双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
    其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

    类加载器加载Class大致要经过如下8个步骤：
        
        1.检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。
        2.如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。
        3.请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。
        4.请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。
        5.当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。
        6.从文件中载入Class，成功后跳至第8步。
        7.抛出ClassNotFountException异常。
        8.返回对应的java.lang.Class对象。
        
![](/images/java/浅析JVM/双亲委派模式工作原理.jpg)

#### 在JVM中表示两个class对象是否为同一个类对象存在两个必要条件
    类的完整类名必须一致，包括包名。
    加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。
        
#### web服务器中的类加载器
    主流的web服务器都实现了自己的类加载器，因为都要解决如下几个问题：
        启动多个java服务时，服务之间引用的jar包被加载到虚拟机后可以互不干扰，包括多个java服务都依赖了同一个jar包，也不会产生冲突
        多个java服务可以共享需要共享的jar包
        支持JSP的服务器，一般都要实现hotSwap功能，也就是修改后无需重启自动重部署的功能
    基于以上原因，如果只用一个classPath来对所有的类进行加载肯定是不行的，所以一般web服务器都会有多个自定义的类加载器分别负责不同classPath下的类加载，比如Tomcat的lib目录下的jar包由一个CommonClassLoader负责加载，而webApps目录中各个项目的WEB-INFO目录下的jar包由WebAppClassLoader加载器加载，CommonClassLoader是WebAppClassLoader的父类加载器，其加载的类可以被WebAppClassLoader加载的类共享，而tomcat会为每个web应用分配一个WebAppClassLoader实例，这些实例加载的类之间互相隔离；对于JSP文件，tomcat会为每个JSP分配一个JspClassLoader实例，当JSP文件发生变化时，原来的加载器实例就会被废弃，tomcat会重新创建加载器实例对该文件重新加载，从而实现热替换

![](/images/java/浅析JVM/tomcat中的类加载结构.jpg)

### 垃圾回收概念与大概过程
![](/images/java/浅析JVM/垃圾回收1.jpeg)

#### 垃圾对象判定标准
    jvm的GC工作主要针对的对象是堆内存，在做GC工作之前，首先要判定堆内存中的对象实例是否为垃圾，通常使用以下两种算法来定义

    1. 引用计数算法
    java在运行时，当有一个地方引用该对象实例，会将这个对象实例加1，引用失效时就减1，jvm在扫描内存时，发现引用计数值为0的则是垃圾对象，计数值大于0的则为活跃对象。
    目前垃圾回收算法，没有采用引用计数算法，原因是在对象互相引用的情况下，无法判定两者是否为垃圾对象。

    2. 根搜索算法
    根搜索算法是以“GC ROOTS”为起始点往下搜索，所有经过的对象合并起来称为引用链，在这引用链里，没有的对象称为垃圾对象，（实际上jvm还做了一个筛选动作，判定当前对象是否执行finalize()方法，如果不需要执行才判定为垃圾对象，这里不做介绍），在引用链里的是活跃对象。那什么样的对象才能称为“GC ROOTS”呢？以下四种可以
    
    虚拟机栈（栈帧中的本地变量表）中引用的对象。
    方法区中的类静态属性引用的对象。
    方法区中的常量引用的对象。
    本地方法栈中 JNI（Native 方法）的引用对象。
    
#### 垃圾回收算法

    1. 标记-清除（Mark-Sweep）
    标记清除流程
    jvm会扫描所有的对象实例，通过根搜索算法，将活跃对象进行标记，jvm再一次扫描所有对象，将未标记的对象进行清除，只有清除动作，不作任何的处理，这样导致的结果会存在很多的内存碎片。
![](/images/java/浅析JVM/标记-清除.jpeg)

    2. 复制（copying）
    复制流程
    jvm扫描所有对象，通过根搜索算法标记被引用的对象，之后会申请新的内存空间，将标记的对象复制到新的内存空间里，存活的对象复制完，会清空原来的内存空间，将新的内存最为jvm的对象存储空间。这样虽然解决了内存内存碎片问题，但是如果对象很多，重新申请新的内存空间会很大，在内存不足的场景下，会对jvm运行造成很大的影响
![](/images/java/浅析JVM/复制.jpeg)

    3. 标记-整理（Mark-compact）
    标记整理流程
    标记整理实际上是在标记清除算法上的优化，执行完标记清除全过程之后，再一次对内存进行整理，将所有存活对象统一向一端移动，这样解决了内存碎片问题。
![](/images/java/浅析JVM/标记-整理.jpeg)

    4. 分代回收
    分代回收算法
    目前jvm常用回收算法就是分代回收，年轻代以复制算法为主，老年代以标记整理算法为主。原因是年轻代对象比较多，每次垃圾回收都有很多的垃圾对象回收，而且要尽可能快的减少生命周期短的对象，存活的对象较少，这时候复制算法比较适合，只要将有标记的对象复制到另一个内存区域，其余全部清除，并且复制的数量较少，效率较高；而老年代是年轻代筛选出来的对象，被标记比较高，需要删除的对象比较少，显然采用标记整理效率较高。
![](/images/java/浅析JVM/分代回收.jpeg)

        java中不同对象的生命周期是不一样的，不同周期对象课采用不同垃圾回收算法，以提高效率，根据对象活跃程度分为年轻代、年老代、持久代。JVM堆区划分为Eden、Survivor、Tenured/Old区。
    
    年轻代
            所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分为Eden区和两个Survivor(一般为两个，也可多个)。
    
    年老代
            在年轻代中经历N次垃圾回收后，仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
    
    持久代
            存放静态文件，如java类、方法等，对垃圾回收没有显著影响
    
    GC:  Garbage Collection 垃圾回收
    Minor GC 
            用于清理年轻代，Eden满了，就触发Minor GC ，清理无用对象，把有用对象放到Survivor1或Survivor2中。
    
    Major GC
            用于清理老年代。
    
    Full GC
            清理年轻代、老年代区域，成本高，对系统性能产生影响
    
    清理过程
    1.        创建新对象，大多数放在Eden区
    
    2.        Eden满了（或达到一定比例），触发Minor GC,   把有用的复制到Survivor1, 同时清空Eden区。
    
    3.        Eden区再次满了，触发Minor GC, 把Eden和Survivor1中有用的，复制到Survivor2, 同时清空Eden，Survivor1。
    
    4.        Eden区第三次满了，触发Minor GC, 把Eden和Survivor2中有用的，复制到Survivor1, 同时清空Eden，Survivor2。
    
            形成循环，Survoivor1和Survivor中来回清空、复制，过程中有一个Survivor处于空的状态用于下次复制的。
    
    5.        重复多次（默认15），没有被Survivor清理的对象，复制到Old（Tenuerd）区.
    
    6.        当Old达到一定比例，触发Major GC，清理老年代。        

    7.        当Old满了，触发Full GC。注意，Full GC清理代价大，系统资源消耗高。

### JAVA内存模型
    Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节。
    此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题
    （如果局部变量是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。

    主内存：java虚拟机规定所有的变量(不是程序中的变量)都必须在主内存中产生，为了方便理解，可以认为是堆区。可以与前面说的物理机的主内存相比，只不过物理机的主内存是整个机器的内存，而虚拟机的主内存是虚拟机内存中的一部分。
    工作内存：java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的为了方便理解，可以认为是虚拟机栈。可以与前面说的高速缓存相比。
        线程的工作内存保存了线程需要的变量在主内存中的副本。虚拟机规定，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也不能相互访问对方的工作内存。
        如果线程之间需要传递变量的值，必须通过主内存来作为中介进行传递。
        
![](/images/java/浅析JVM/内存模型.png)

![](/images/java/浅析JVM/内存模型2.jpg)

### JVM方法调用过程
    JVM的静态绑定和动态绑定
    
        Java虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符是由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么Java虚拟机会在类的验证阶段报错。
        
        可以看到，Java虚拟机与Java语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此Java虚拟机能够准确地识别目标方法。
        
        Java虚拟机中关于方法重写的判定同样基于方法描述符。如果子类定义了与父类中非私有、非静态的同名方法，那么只有当这两个方法的参数类型以及返回类型一致，Java虚拟机才会判定为重写。
        
        对于Java语言中重写而Java虚拟机中非重写的情况，编译器会通过生成桥接方法来实现Java中的重写语义。
        
        由于对重载方法的区分在编译阶段已经完成，我们可以认为Java虚拟机不存在重载这一概念。因此，在某些文章中，重载也被称为静态绑定（static binding），或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。这个说法在Java虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此Java编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。
        
        具体来说，Java字节码中与调用相关的指令共有五种。
        
        1.invokestatic：用于调用静态方法。
        
        2.invokespecial：用于调用私有实例方法、构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
        
        3.invokevirtual：用于调用非私有实例方法。
        
        4.invokeinterface：用于调用接口方法。
        
        5.invokedynamic：用于调用动态方法。

    调用指令的符号引用
        
        在编译过程中，我们并不知道目标方法的具体内存地址。因此，Java编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符。
        
        符号引用存储在class文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。
        
        在执行使用了符号引用的字节码前，Java虚拟机需要解析这些符号引用，并替换为实际引用。
        
        对于非接口符号引用，假定该符号引用所指向的类为C，则Java虚拟机会按照如下步骤进行查找。
        
        1.在C中查找符合名字及描述符的方法。
        
        2.如果没有找到，在C中的父类中继续搜索，直至Object类。
        
        3.如果没有找到，在C所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。如果目标方法在间接实现的接口中，则需满足C与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。
        
        从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。

    对与接口符号引用，假定该符号引用所指向的接口为I，则Java虚拟机会按照如下步骤进行查找。
    
        1.在I中查找符合名字及描述符的方法。
        
        2.如果没有找到，在Object类中的公有实例方法中搜索。
        
        3.如果没有找到，则在I的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤3的要求一致。
        
    经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。

### 虚拟机执行大概过程

    所谓解释之行，就是通过解释器来读取字节码，遇到相应的指令就去执行该指令。
    所谓编译执行，就是通过即时编译器(just in time jit)将字节码转换为本地机器码执行，现代jvm会根据代码热点生成相应的本地机器码。

![](/images/java/浅析JVM/执行流程.png)

### 编译优化
    1. 早期（编译期）优化
        Java 语言的编译期是一段不确定的操作过程，它可以分为三类编译过程。
        前端编译：把 .java 文件转变为 .class 文件。
        后端编译：把字节码转变为机器码。
        静态提前编译：直接把 *.java 文件编译成本地机器码。
    
    2. 晚期（运行期）优化
        Java 程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为 热点代码（Hot Spot Code）。
        为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，简称 JIT 编译器）。
        它是虚拟机中最核心且最能体现虚拟机水平的部分。
        众多主流的虚拟机都同时包含 解释器 和 JIT 编译器，解释器与 JIT 编译器各有优势。

### 演示编译后的字节码 心算执行过程
    dk-12\bin\javap.exe
    -v $FileClass$
    $OutputPath$
    执行每一条指令之前，Java虚拟机要求该指令的操作数已被压入操作数栈中。
    在执行指令时，Java虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中。
    
```
public class Demo {  
    public static void foo() {  
        int a = 1;  
        int b = 2;  
        int c = (a + b) * 5;  
    }  
}  
```
```
0:  iconst_1  
1:  istore_0  
2:  iconst_2  
3:  istore_1  
4:  iload_0  
5:  iload_1  
6:  iadd  
7:  iconst_5  
8:  imul  
9:  istore_2  
10: return  
```
![](/images/java/浅析JVM/字节码运行.gif)
    
### 各种小知识点

### 推荐书籍
    1、深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)
    2、揭秘Java虚拟机：JVM设计原理与实现
    3、Java虚拟机规范(Java SE 8版)
    4、实战Java虚拟机：JVM故障诊断与性能优化
    5、HotSpot实战
    6、自己动手写Java虚拟机
    7、深入理解JVM ＆ G1 GC
    8、垃圾回收的算法与实现
    9、Java虚拟机精讲